{"name":"Common Composition","tagline":"Portable component composition annotations, dependency injection framework agnostic.","body":"Common Composition\r\n=================\r\n\r\nPortable component composition annotations, dependency injection framework agnostic.\r\n\r\n## Why\r\nTypically, application logic doesn't require deep knowledge of specific dependency injection framework features, APIs and extensibility points. It can even be considered a best practice to keep your logic code devoid of specific DI frameworks types and quirks. \r\n\r\nMost frameworks today allow for convention-based registration of components (like \"register all concrete types with their implemented interfaces\"). A typical annotation that's usually needed is whether the registered component should be instantiated only once in a container and reused (like a container-scoped singleton) or if a new instance should be created every time the component is requested. \r\n\r\nIt would be clearly desirable to be able to express that type of annotation (as well as whether a type should be registered for composition at all) in a framework agnostic way. That's precisely what Common Composition is for. \r\n\r\nThe Common Composition provides basic annotation attributes you need to specify how components should be composed in a dependency injection container. It allows your application logic to remain DI framework agnostic while still leveraging the benefits of convention-based configuration.\r\n\r\nIn addition, Common Composition will provide a set of default configurations for various containers so that the behave consistently with regards to some common relationship types, such as dependencies on Func<T> factories, IEnumerable<T>, etc.\r\n\r\n### What about Common Service Locator?\r\nThe [Common Service Locator](http://commonservicelocator.codeplex.com/) project also provides an abstraction over IoC containers, but it's intended consumers are other frameworks, not application code. So much that a Service Locator is considered by most to be an [anti-pattern](https://www.google.com.ar/search?q=service+locator+anti+pattern). \r\n\r\nYour application code should clearly NOT depend on that abstraction.\r\n\r\n\r\n## What\r\nThe goal is to keep the annotations you make on your application logic to a minimum. Currently, you can annotate your types that should be registered for composition with the `[ComponentAttribute]`:\r\n\r\n    [Component(IsSingleton = false)]\r\n    public class Foo : IFoo\r\n    {\r\n        public Foo(IBar bar)\r\n        {\r\n            this.Bar = bar;\r\n        }\r\n\r\n        public IBar Bar { get; private set; }\r\n    }\r\n\r\n    [Component(IsSingleton = true)]\r\n    internal class Bar : IBar { } \r\n\r\n    public interface IComponent { }\r\n    public interface IFoo : IComponent { }\r\n    public interface IBar : IComponent { }\r\n\r\n\r\nUnder Common Composition conventions, all major dependency injection frameworks (Autofac, Ninject, Windsor, Unity and MEF) will make both Foo and Bar available (note Bar is an internal class), and resolving all IComponent instances will shield both Foo and Bar. Also, resolving twice the Bar/IBar component will return the same instance, since it's configured to be a singleton.\r\n\r\nA common set of unit tests that run and are required to pass on all supported containers, ensures this common set of behaviors. \r\n\r\nHere's how to leverage Common Composition on each of the supported frameworks:\r\n\r\n1. Autofac:\r\n\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterComponents(typeof(IFoo).Assembly);\r\n\r\n            var container = builder.Build();\r\n\r\n2. Ninject:\r\n\r\n            var kernel = new Ninject.StandardKernel();\r\n\r\n            kernel.RegisterComponents(typeof(IFoo).Assembly);\r\n\r\n3. Windsor:\r\n\r\n            var container = new WindsorContainer();\r\n\r\n            container.RegisterComponents(typeof(IFoo).Assembly);\r\n\r\n4. Unity:\r\n\r\n            var container = new UnityContainer();\r\n\r\n            container.RegisterComponents(typeof(IFoo).Assembly);\r\n\r\n5. MEF:\r\n\r\n            var catalog = new ComponentCatalog(typeof(IFoo).Assembly);\r\n            var container = new CompositionContainer(catalog);\r\n\r\n\r\n## Install\r\n\r\nOn your application logic projects:\r\n\r\n            install-package CommonComposition\r\n\r\nOn your application bootstrapping code (i.e. your Main(), or web application startup procedure, etc.), depending on the chosen container implementation:\r\n\r\n            install-package CommonComposition.Autofac\r\n            install-package CommonComposition.Ninject\r\n            install-package CommonComposition.Windsor\r\n            install-package CommonComposition.Unity\r\n            install-package CommonComposition.Mef\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}